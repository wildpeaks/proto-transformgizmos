#VRML V2.0 utf8

EXTERNPROTO TranslateGizmo [
	exposedField  SFVec3f     translation
	exposedField  SFRotation  rotation
	exposedField  SFVec3f     scale
	eventOut      SFTime      dragStart
	eventOut      SFTime      dragEnd
	eventOut      SFVec3f     delta_changed
] "proto.TranslateGizmo.wrl#TranslateGizmo"

EXTERNPROTO RotateGizmo [
	exposedField  SFVec3f     translation
	exposedField  SFRotation  rotation
	exposedField  SFVec3f     scale
	eventOut      SFTime      dragStart
	eventOut      SFTime      dragEnd
	eventOut      SFRotation  delta_changed
#	eventOut      SFFloat     deltaX_changed
#	eventOut      SFFloat     deltaY_changed
#	eventOut      SFFloat     deltaZ_changed
] "proto.RotateGizmo.wrl#RotateGizmo"

EXTERNPROTO ConstantSize [
	exposedField  SFVec3f  translation
	exposedField  SFVec3f  scaleFactor
	eventOut      SFVec3f  scale
] "proto.ConstantSize.wrl#ConstantSize"


PROTO TransformGizmos [

	# Transform type:
	# -1: none
	#  0: global translate
	#  1: global rotation
	#  2: local translate
	#  3: local rotation
	exposedField  SFInt32     type                  -1

	# Transform-like object that gets edited by the gizmos
	exposedField  SFNode      target                NULL

	# Call this when the target ever changes for another reason than the gizmos
	eventIn       SFTime      forceUpdate
]{
	DEF gizmosTransform Transform {
		children DEF gizmosSwitch Switch {
			choice [
				DEF translateGizmo TranslateGizmo{}
				DEF rotateGizmo RotateGizmo{}
			]
		}
	}

	DEF	TODELETE Transform	{
		children Shape {
			appearance Appearance {
				material Material {emissiveColor 1 1 0}
			}
			geometry Text {
				string "DEBUG"
				fontStyle FontStyle {
					size 10
					justify	"MIDDLE"
				}
			}
		}
	}

	DEF script Script {
		field         SFNode      EMPTY_SFNODE           NULL
		field         SFVec3f     EMPTY_SFVEC3F          0 0 0
		field         SFRotation  EMPTY_SFROTATION       0 1 0 0
		field         SFNode      gizmosSwitch           USE gizmosSwitch

		exposedField  SFInt32     type                   IS type
		field         SFInt32     TYPE_NONE              -1
		field         SFInt32     TYPE_GLOBAL_TRANSLATE  0
		field         SFInt32     TYPE_GLOBAL_ROTATE     1
		field         SFInt32     TYPE_LOCAL_TRANSLATE   2
		field         SFInt32     TYPE_LOCAL_ROTATE      3

		exposedField  SFNode      target                 IS target
		exposedField  SFVec3f     gizmoTranslation       0 0 0
		exposedField  SFRotation  gizmoRotation          0 1 0 0
		field         SFVec3f     dragStartTranslation   0 0 0
		field         SFRotation  dragStartRotation      0 1 0 0
		field         SFMatrix    dragStartMatrix        1 0 0 0  0 1 0 0  0 0 1 0  0 0 0 1

		eventIn       SFTime      onDragStart
		eventIn       SFTime      onDragEnd
		eventIn       SFVec3f     onTranslationDelta
		eventIn       SFRotation  onRotationDelta
#		eventIn       SFFloat     onRotationDeltaX
#		eventIn       SFFloat     onRotationDeltaY
#		eventIn       SFFloat     onRotationDeltaZ
		eventIn       SFTime      updateGizmos           IS forceUpdate

		field SFNode TODELETE USE TODELETE

		directOutput TRUE
		url "javascript:


		//-------------------------------------------------------------------//
		// Maths
		//-------------------------------------------------------------------//

		function mergeRotations(parentRotation, childRotation){
			var parentMatrix = new VrmlMatrix();
			var childMatrix = new VrmlMatrix();
			var mergedRotation = new SFRotation();
			parentMatrix.setTransform(EMPTY_SFVEC3F, parentRotation);
			childMatrix.setTransform(EMPTY_SFVEC3F, childRotation);
			parentMatrix.multLeft(childMatrix).getTransform(null, mergedRotation, null);
			return mergedRotation;
		}

		function mergeMatrices(parentMatrix, childMatrix){
			return parentMatrix.multLeft(childMatrix);
		}

		function unmergeMatrices(mergedMatrix, parentMatrix){
			return parentMatrix.inverse().multLeft(mergedMatrix);
		}

		function getTranslationMatrix(translation){
			var transform = new SFNode('Transform{}');
			transform.translation = translation;
			return new VrmlMatrix(transform.getMatrix());
		}

		function getRotationMatrix(rotation){
			var transform = new SFNode('Transform{}');
			transform.rotation = rotation;
			return new VrmlMatrix(transform.getMatrix());
		}

		function getTranslation(matrix){
			var transform = new SFNode('Transform{}');
			transform.setMatrix(matrix);
			return new SFVec3f(transform.translation);
		}

		function getRotation(matrix){
			var transform = new SFNode('Transform{}');
			transform.setMatrix(matrix);
			return new SFRotation(transform.rotation);
		}


		//-------------------------------------------------------------------//
		// Gizmo
		//-------------------------------------------------------------------//

		function updateGizmos(){
			if (target != EMPTY_SFNODE){
				var isLocal = (type == TYPE_LOCAL_TRANSLATE) || (type == TYPE_LOCAL_ROTATE);
				gizmoTranslation = target.translation;
				gizmoRotation = isLocal ? target.rotation : EMPTY_SFROTATION;
				gizmosSwitch.whichChoice = ((type == TYPE_GLOBAL_TRANSLATE) || (type == TYPE_LOCAL_TRANSLATE)) ? 0 : 1;
			} else {
				gizmosSwitch.whichChoice = -1;
			}
		}

		function onDragStart(){
			dragStartTranslation = new SFVec3f(target.translation);
			dragStartRotation = new SFRotation(target.rotation);
			dragStartMatrix = new VrmlMatrix(target.getMatrix());
		}

		function onDragEnd(){
			updateGizmos();
		}
		function type(){
			updateGizmos();
		}
		function target(){
			updateGizmos();
		}
		function initialize(){
			updateGizmos();
		}


		//-------------------------------------------------------------------//
		// Apply the delta
		//-------------------------------------------------------------------//

		function onTranslationDelta(delta){
			var globalDeltaMatrix = mergeMatrices(
				getRotationMatrix(gizmoRotation),
				getTranslationMatrix(delta)
			);
			var globalDelta = getTranslation(globalDeltaMatrix);
			target.translation = dragStartTranslation.add(globalDelta);
		}


//		function onRotationDeltaX(delta){ // BLUE
//			//
//			//
//		}

//		function onRotationDeltaY(delta){ // GREEN
//			//
//			//
//		}

//		function onRotationDeltaZ(delta){ // RED
//			var localDelta = new SFRotation(0, 0, 1, delta);
//			var globalDelta = mergeRotations(gizmoRotation, localDelta);
//			target.rotation = globalDelta;
//		}


		function onRotationDelta(delta){ // RED
			if (type == TYPE_LOCAL_ROTATE){
				target.rotation = mergeRotations(gizmoRotation, delta); // ... but isn't gizmoRotation the same as dragStartRotation basically ? hmm, probably false hope then
			} else {
				target.rotation = mergeRotations(delta, dragStartRotation);
			}
		}


		/**********************************************************************
		function onRotationDelta(delta){
			if (type == TYPE_LOCAL_ROTATE){
//				trace('DELTA ' + delta);
				// blue = X
				// green = Y
				// red = Z


				// NOPE
//				var globalDeltaMatrix = mergeMatrices(
//					getRotationMatrix(gizmoRotation),
//					getRotationMatrix(delta)
//				);
//				var newMatrix = mergeMatrices(
//					globalDeltaMatrix,
//					getRotationMatrix(initialRotation)
//				);
//				target.rotation


				// Close, but nope
//				var gizmoRotationMatrix = getRotationMatrix(gizmoRotation);
//				target.setMatrix(
//					mergeMatrices(
//						getTranslationMatrix(dragStartTranslation),
//						unmergeMatrices(
//							mergeMatrices(
//								getRotationMatrix(delta),
//								mergeMatrices(
//									gizmoRotationMatrix,
//									getRotationMatrix(dragStartRotation)
//								)
//							),
//							gizmoRotationMatrix
//						)
//					)
//				);


				// When rotation was global
//				var globalDeltaMatrix = getRotationMatrix(delta);
//				var outerRotationMatrix = getRotationMatrix(outerRotation);
//
//				var initialTranslationMatrix = getTranslationMatrix(initialTranslation);
//				var initialRotationMatrix = getRotationMatrix(initialRotation);
//
//				var globalInitialRotationMatrix = mergeMatrices(outerRotationMatrix, initialRotationMatrix);
//				var globalInitialRotationMatrixPlusDelta = mergeMatrices(globalDeltaMatrix, globalInitialRotationMatrix);
//				var localInitialRotationMatrixPlusDelta = unmergeMatrices(globalInitialRotationMatrixPlusDelta, outerRotationMatrix);
//				var localInitialMatrixPlusDelta = mergeMatrices(initialTranslationMatrix, localInitialRotationMatrixPlusDelta);
//				innerTarget.setMatrix(localInitialMatrixPlusDelta);


				// NOPE, not even close
//				var globalDeltaMatrix = mergeMatrices(
//					getRotationMatrix(gizmoRotation),
//					getRotationMatrix(delta)
//				);
//				var outerRotationMatrix = getRotationMatrix(gizmoRotation);
//
//				var initialTranslationMatrix = getTranslationMatrix(dragStartTranslation);
//				var initialRotationMatrix = getRotationMatrix(dragStartRotation);
//
//				var globalInitialRotationMatrix = mergeMatrices(outerRotationMatrix, initialRotationMatrix);
//				var globalInitialRotationMatrixPlusDelta = mergeMatrices(globalDeltaMatrix, globalInitialRotationMatrix);
//				var localInitialRotationMatrixPlusDelta = unmergeMatrices(globalInitialRotationMatrixPlusDelta, outerRotationMatrix);
//				var localInitialMatrixPlusDelta = mergeMatrices(initialTranslationMatrix, localInitialRotationMatrixPlusDelta);
//				target.setMatrix(localInitialMatrixPlusDelta);


				// NOPE, nice try though <-- but why ???? it seems like the logical way to do it ????
//				var globalDelta = mergeRotations(gizmoRotation, delta);
//				target.rotation = TODELETE.rotation = mergeRotations(globalDelta, dragStartRotation);


				// NOPE, like completely
//				var globalDelta = mergeRotations(gizmoRotation.inverse(), delta);
//				target.rotation = mergeRotations(globalDelta, dragStartRotation);


				// Great, I keep going in circles and going back down to delta
//				TODELETE.rotation = delta;
//				var globalDelta = mergeRotations(gizmoRotation, delta);
//				var globalDeltaMatrix = getRotationMatrix(globalDelta);
////				TODELETE.rotation = globalDelta; // it does seem correct, i think ? but it has the extra gizmoRotation baked in, hmm, but wouldn't unmerge go back to delta ??
//				var globalInitialRotationMatrix = getRotationMatrix(dragStartRotation);
//				var backToDelta = unmergeMatrices(globalDeltaMatrix, globalInitialRotationMatrix);


				// How about rotation gizmo sending 3 events, one per direction, then I can know the direction ?


			} else {
				target.rotation = mergeRotations(delta, dragStartRotation);
			}
		}
		**********************************************************************/


		"
	}

	DEF constant ConstantSize {
		scaleFactor 0.2 0.2 0.2
	}
	ROUTE constant.scale TO translateGizmo.scale
	ROUTE constant.scale TO rotateGizmo.scale

	ROUTE script.gizmoTranslation TO constant.translation
	ROUTE script.gizmoTranslation TO gizmosTransform.translation
	ROUTE script.gizmoRotation TO gizmosTransform.rotation

	ROUTE translateGizmo.delta_changed TO script.onTranslationDelta
	ROUTE translateGizmo.dragStart TO script.onDragStart
	ROUTE translateGizmo.dragEnd TO script.onDragEnd

	ROUTE rotateGizmo.delta_changed TO script.onRotationDelta
#	ROUTE rotateGizmo.deltaX_changed TO script.onRotationDeltaX
#	ROUTE rotateGizmo.deltaY_changed TO script.onRotationDeltaY
#	ROUTE rotateGizmo.deltaZ_changed TO script.onRotationDeltaZ
	ROUTE rotateGizmo.dragStart TO script.onDragStart
	ROUTE rotateGizmo.dragEnd TO script.onDragEnd
}
